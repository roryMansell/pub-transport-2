<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>London Bus RT – Minimal (v1 smooth + polyline)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial; }
    .app { display:flex; height:100%; }
    .sidebar { width:320px; border-right:1px solid #ddd; padding:12px; overflow:auto; }
    .map { flex:1; }
    .row { display:flex; gap:6px; margin-bottom:8px; }
    .muted { color:#666; font-size:12px; margin-bottom:8px; }
    .route-item { display:flex; align-items:center; gap:8px; padding:3px 0; }
    .route-id { font-family: ui-monospace, Menlo, Consolas, monospace; width:56px; }
    .loading { font-size:12px; color:#888; }
    .error { color:#b00020; font-size:12px; white-space:pre-wrap; }
    .leaflet-pane .vehicle-arrow { z-index: 500; }
    button { cursor:pointer; }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <h3>London bus routes</h3>
      <div class="row">
        <input id="search" placeholder="Search route (e.g. 88, 214, N5)" style="flex:1; padding:6px;">
        <button id="clear">Clear</button>
      </div>
      <div class="muted">Tick routes to load vehicles. Polls every 5s; animation is continuous.</div>
      <div class="muted" style="margin-bottom:6px;">
        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#888;vertical-align:middle;margin-right:6px;border:2px solid #0002"></span>
        Stops are white dots with a colored ring. Buses are colored arrows moving along the route.
      </div>
      <div id="status" class="loading">Loading routes…</div>
      <div id="routes"></div>
    </div>
    <div id="map" class="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ==============================
    // Config
    // ==============================
    const API = "https://pub-transport-2.onrender.com";
    const AVG_SPEED_MPS = 7;           // ~25 km/h moving average
    const MIN_SLICE_SEC = 20;          // plausible minimum between stops
    const MAX_ETA_SEC = 1800;
    const START_FRACTION_CLAMP = [0.02, 0.98]; // never exactly on a stop

    // ==============================
    // DOM/state
    // ==============================
    const routesEl = document.getElementById('routes');
    const searchEl = document.getElementById('search');
    const clearBtn = document.getElementById('clear');
    const statusEl = document.getElementById('status');

    let allRoutes = [];
    let selected = new Set();
    let pollTimer = null;

    // lineId -> {
    //   group, vehicles(Map), color,
    //   pathIn, cumIn, idxInByStop(Map),
    //   pathOut, cumOut, idxOutByStop(Map)
    // }
    const lineLayers = new Map();

    // ==============================
    // Map
    // ==============================
    const map = L.map('map').setView([51.5074, -0.1278], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap',
      maxZoom: 19
    }).addTo(map);

    // ==============================
    // Helpers
    // ==============================
    const hash = (s) => { let h=0; for (let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); };
    const colorFor = (lineId) => `hsl(${hash(lineId)%360}, 75%, 45%)`;
    const vKey = (lineId, vid) => `${String(lineId).trim()}::${String(vid).trim()}`;

    function busIcon(color, rotationDeg) {
      const html =
        `<div class="vehicle-arrow" style="transform: rotate(${rotationDeg}deg); transform-origin: 50% 50%;">
           <div style="
             width:0; height:0;
             border-left:9px solid transparent;
             border-right:9px solid transparent;
             border-bottom:18px solid ${color};
             filter: drop-shadow(0 1px 2px rgba(0,0,0,0.45));
           "></div>
         </div>`;
      return L.divIcon({ className: 'bus-divicon', html, iconSize: [20,20], iconAnchor: [10,10] });
    }

    function bearingDeg(lat1, lon1, lat2, lon2) {
      const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
      const φ1 = toRad(lat1), φ2 = toRad(lat2), Δλ = toRad(lon2 - lon1);
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      let brng = toDeg(Math.atan2(y, x));
      return (brng + 360) % 360;
    }

    async function fetchJSON(url) {
      const r = await fetch(url, { mode: "cors" });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}\n${await r.text()}`);
      return r.json();
    }

    function setStatus(msg, css = "loading") { statusEl.className = css; statusEl.textContent = msg; }

    // ==============================
    // Polyline helpers
    // ==============================
    function haversineMeters(a, b) {
      const R = 6371000;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(b[0] - a[0]);
      const dLon = toRad(b[1] - a[1]);
      const lat1 = toRad(a[0]), lat2 = toRad(b[0]);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function cumulativeDistances(points) {
      const cum = [0];
      for (let i = 1; i < points.length; i++) cum[i] = cum[i-1] + haversineMeters(points[i-1], points[i]);
      return cum;
    }
    function lowerBound(cum, lo, hi, target) {
      lo = Math.max(0, lo); hi = Math.min(cum.length-1, hi);
      while (lo < hi) { const mid = (lo+hi)>>1; if (cum[mid] < target) lo = mid+1; else hi = mid; }
      return lo;
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function interpPoint(a, b, t) { return [lerp(a[0], b[0], t), lerp(a[1], b[1], t)]; }

    // LatLng at absolute distance D along [i0..i1] (handles reversed order)
    function pointAtDistanceOnSlice(points, cum, iA, iB, targetD) {
      const i0 = Math.min(iA, iB), i1 = Math.max(iA, iB);
      const startD = cum[i0], endD = cum[i1];
      const tDist = Math.max(startD, Math.min(endD, targetD));
      const j = lowerBound(cum, i0, i1, tDist);
      if (j === i0) return points[i0];
      const segLen = cum[j] - cum[j-1];
      const segT = segLen > 0 ? (tDist - cum[j-1]) / segLen : 0;
      return interpPoint(points[j-1], points[j], Math.max(0, Math.min(1, segT)));
    }

    // Tangent heading along the polyline at posD
    function headingOnSlice(meta, posD, stepMeters = 5) {
      const { path, cum, iPrev, iNext } = meta;
      const dirSign = Math.sign(cum[iNext] - cum[iPrev]) || 1;
      const a = pointAtDistanceOnSlice(path, cum, iPrev, iNext, posD - stepMeters * dirSign);
      const b = pointAtDistanceOnSlice(path, cum, iPrev, iNext, posD + stepMeters * dirSign);
      return bearingDeg(a[0], a[1], b[0], b[1]);
    }

    // ==============================
    // UI
    // ==============================
    function renderRoutes() {
      const q = (searchEl.value || "").trim().toLowerCase();
      const filtered = q
        ? allRoutes.filter(r => r.id.toLowerCase().includes(q) || (r.name||"").toLowerCase().includes(q))
        : allRoutes;

      routesEl.innerHTML = "";
      filtered.slice(0, 300).forEach(r => {
        const label = document.createElement('label');
        label.className = 'route-item';

        const swatch = document.createElement('span');
        Object.assign(swatch.style, { display:'inline-block', width:'10px', height:'10px', borderRadius:'50%', background: colorFor(r.id) });

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selected.has(r.id);
        cb.addEventListener('change', () => {
          if (cb.checked) { selected.add(r.id); ensureRouteLoaded(r.id); }
          else { selected.delete(r.id); removeRouteLayers(r.id); }
          schedulePolling();
        });

        const idSpan = document.createElement('span'); idSpan.className = 'route-id'; idSpan.textContent = r.id;
        const nameSpan = document.createElement('span'); nameSpan.textContent = r.name || r.id;

        label.appendChild(cb); label.appendChild(swatch); label.appendChild(idSpan); label.appendChild(nameSpan);
        routesEl.appendChild(label);
      });

      if (filtered.length > 300) {
        const note = document.createElement('div'); note.className = 'muted'; note.textContent = 'Showing first 300. Refine your search.'; routesEl.appendChild(note);
      }
    }

    function schedulePolling() {
      if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }

      for (const id of Array.from(lineLayers.keys())) {
        if (!selected.has(id)) removeRouteLayers(id);
      }

      if (selected.size === 0) {
        map.eachLayer(l => { if (!(l instanceof L.TileLayer)) { try { l.remove(); } catch { map.removeLayer(l); } } });
        setStatus("No routes selected. Tick some on the left.", "muted");
        return;
      }

      setStatus("Live updating…", "muted");

      const load = async () => {
        const lines = Array.from(selected);
        try {
          await updateVehicles(lines);
        } catch (e) {
          setStatus("Error: " + e.message, "error");
        }
      };

      load();
      pollTimer = setInterval(load, 5000);
    }

    function removeRouteLayers(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      try { layers.group.remove(); } catch { map.removeLayer(layers.group); }
      lineLayers.delete(lineId);
    }

    // ==============================
    // Load lines (shape + stops)
    // ==============================
    async function ensureRouteLoaded(lineId) {
      if (lineLayers.has(lineId)) return;
      const color = colorFor(lineId);

      const group = L.featureGroup().addTo(map);
      const vehicles = new Map(); // key -> { marker, meta }

      const [shape, stops] = await Promise.all([
        fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/shape`),
        fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/stops`)
      ]);

      const pickPath = (segments) => {
        let best = null;
        for (const s of (segments || [])) if (Array.isArray(s) && s.length >= 2)
          best = !best || s.length > best.length ? s : best;
        return best || [];
      };
      const pathIn = pickPath(shape.inbound);
      const pathOut = pickPath(shape.outbound);

      const cumIn  = pathIn.length  ? cumulativeDistances(pathIn)  : [];
      const cumOut = pathOut.length ? cumulativeDistances(pathOut) : [];

      // map stop id -> nearest index on its direction path
      const nearestIndex = (path, stop) => {
        if (!path.length) return null;
        let bestIdx = 0, bestD = Infinity;
        for (let i = 0; i < path.length; i++) {
          const d = haversineMeters(path[i], [stop.lat, stop.lon]);
          if (d < bestD) { bestD = d; bestIdx = i; }
        }
        return bestIdx;
      };
      const idxInByStop = new Map();
      const idxOutByStop = new Map();
      (stops.inbound || []).forEach(sp => { if (sp.lat!=null && sp.lon!=null) { const idx = nearestIndex(pathIn, sp); if (idx!=null) idxInByStop.set(sp.id, idx); }});
      (stops.outbound || []).forEach(sp => { if (sp.lat!=null && sp.lon!=null) { const idx = nearestIndex(pathOut, sp); if (idx!=null) idxOutByStop.set(sp.id, idx); }});

      if (pathIn.length)  L.polyline(pathIn,  { color, weight: 4, opacity: 0.85 }).addTo(group);
      if (pathOut.length) L.polyline(pathOut, { color, weight: 4, opacity: 0.55, dashArray: "6,6" }).addTo(group);

      // stops layer
      const stopsLayer = L.layerGroup().addTo(group);
      const addStops = (arr) => (arr || []).forEach(sp => {
        if (sp.lat == null || sp.lon == null) return;
        L.circleMarker([sp.lat, sp.lon], { radius: 6, color: '#0000', weight: 0, fillColor: '#000', fillOpacity: 0.08 }).addTo(stopsLayer);
        L.circleMarker([sp.lat, sp.lon], { radius: 5, color, weight: 3, fillColor: '#fff', fillOpacity: 1.0 })
          .bindPopup(`<b>${sp.name || "Stop"}</b>`, { autoPan:false })
          .addTo(stopsLayer);
      });
      addStops(stops.inbound); addStops(stops.outbound);

      // fit once
      const allPts = [...pathIn, ...pathOut];
      if (allPts.length) {
        const b = L.latLngBounds(allPts.map(p => L.latLng(p[0], p[1])));
        map.fitBounds(b, { padding: [20, 20], maxZoom: 14 });
      }

      lineLayers.set(lineId, {
        group, vehicles, color,
        pathIn, cumIn, idxInByStop,
        pathOut, cumOut, idxOutByStop
      });
    }

    // ==============================
    // Vehicles: poll + maintain state
    // ==============================
    async function updateVehicles(lines) {
      await Promise.all(lines.map(ensureRouteLoaded));
      await Promise.all(lines.map(loadLine));
    }

    function popupHtml(v) {
      return (
        `<b>Route:</b> ${v.route}<br>` +
        `<b>Vehicle:</b> ${v.vehicle_id}<br>` +
        (v.eta_seconds != null ? `<b>ETA:</b> ${Math.max(0, Math.round(v.eta_seconds/60))} min<br>` : "") +
        `${v.next_stop_name ? `<b>Next stop:</b> ${v.next_stop_name}` : ""}`
      );
    }

    async function loadLine(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      const { vehicles, color, pathIn, cumIn, idxInByStop, pathOut, cumOut, idxOutByStop } = layers;

      const data = await fetchJSON(`${API}/vehicles?line_id=${encodeURIComponent(lineId)}`);
      const fetchedAtMs = Date.now(); // use client clock to avoid skew
      const list = data.vehicles || [];
      const seen = new Set();

      for (const v of list) {
        const key = vKey(lineId, v.vehicle_id);
        seen.add(key);

        const hasPrev = (v.prev_stop_id && v.prev_lat != null && v.prev_lon != null);
        const hasNext = (v.next_stop_id && v.next_lat != null && v.next_lon != null);
        if (!hasPrev || !hasNext) continue;

        const dir = (v.direction || "").toLowerCase().startsWith("out") ? "outbound" : "inbound";
        const path = dir === "outbound" ? pathOut : pathIn;
        const cum  = dir === "outbound" ? cumOut  : cumIn;
        const idxMap  = dir === "outbound" ? idxOutByStop : idxInByStop;

        if (!path.length || !cum.length) continue;

        const iPrev = idxMap.get(v.prev_stop_id);
        const iNext = idxMap.get(v.next_stop_id);
        if (iPrev == null || iNext == null || iPrev === iNext) continue;

        const startD = cum[iPrev];
        const endD   = cum[iNext];
        const length = Math.abs(endD - startD);
        if (length < 1) continue;

        const eta = Math.max(1, Math.min(MAX_ETA_SEC, v.eta_seconds || MIN_SLICE_SEC));
        const estDur = Math.max(MIN_SLICE_SEC, length / AVG_SPEED_MPS); // seconds
        let p0 = 1 - (eta / estDur); // fraction traversed toward next stop
        p0 = Math.max(START_FRACTION_CLAMP[0], Math.min(START_FRACTION_CLAMP[1], p0));

        const dirSign = Math.sign(endD - startD) || 1;
        const inferredPosD = startD + dirSign * (p0 * length);

        let st = vehicles.get(key);

        if (!st) {
          const angle0 = headingOnSlice({ path, cum, iPrev, iNext }, inferredPosD, 5);
          const marker = L.marker(
            pointAtDistanceOnSlice(path, cum, iPrev, iNext, inferredPosD),
            { icon: busIcon(color, angle0) }
          ).addTo(layers.group)
           .bindPopup(popupHtml(v), { autoPan:false, closeButton:true, autoClose:false });
          st = { marker, meta: null };
          vehicles.set(key, st);
        } else {
          st.marker.getPopup()?.setContent(popupHtml(v));
        }

        const arrivalAt = fetchedAtMs + eta * 1000;

        if (!st.meta || st.meta.dir !== dir || st.meta.iPrev !== iPrev || st.meta.iNext !== iNext) {
          // New slice starting from inferred position; compute speed to hit end at ETA
          const denom = Math.max(200, arrivalAt - fetchedAtMs); // ms
          const speed = (endD - inferredPosD) / (denom / 1000); // m/s (signed)
          st.meta = {
            dir, iPrev, iNext, path, cum,
            color,
            posD: inferredPosD,
            speed,
            lastMs: Date.now(), // use client clock
            endD, arrivalAt
          };
        } else {
          // Same slice: advance to now, then retarget speed to meet new ETA
          const now = Date.now();
          const dt = Math.max(0, now - st.meta.lastMs) / 1000;
          st.meta.posD += st.meta.speed * dt;
          st.meta.lastMs = now;

          st.meta.endD = endD;
          st.meta.arrivalAt = arrivalAt;
          st.meta.color = color;

          const remainingMs = Math.max(200, arrivalAt - now);
          const remainingDist = st.meta.endD - st.meta.posD;
          const targetSpeed = remainingDist / (remainingMs / 1000);
          st.meta.speed = st.meta.speed * 0.6 + targetSpeed * 0.4;

          const minD = Math.min(startD, endD), maxD = Math.max(startD, endD);
          st.meta.posD = Math.max(minD, Math.min(maxD, st.meta.posD));
        }

        // Place immediately after poll
        const ll = pointAtDistanceOnSlice(path, cum, iPrev, iNext, st.meta.posD);
        const angle = headingOnSlice(st.meta, st.meta.posD, 5);
        st.marker.setLatLng(ll);
        st.marker.setIcon(busIcon(color, angle));
      }

      // Remove stale vehicles
      for (const [key, st] of Array.from(vehicles.entries())) {
        if (!seen.has(key)) {
          try { st.marker.remove(); } catch {}
          vehicles.delete(key);
        }
      }
    }

    // ==============================
    // Animation loop (continuous)
    // ==============================
    let rafId = null;
    function animate() {
      const now = Date.now();
      for (const { vehicles } of lineLayers.values()) {
        for (const st of vehicles.values()) {
          const { marker, meta } = st;
          if (!meta) continue;

          const dt = Math.max(0, now - meta.lastMs) / 1000;
          meta.lastMs = now;

          meta.posD += meta.speed * dt;

          const startD = meta.cum[meta.iPrev];
          const endD   = meta.cum[meta.iNext];
          const minD = Math.min(startD, endD), maxD = Math.max(startD, endD);
          if (meta.posD < minD) meta.posD = minD;
          if (meta.posD > maxD) meta.posD = maxD;

          const ll = pointAtDistanceOnSlice(meta.path, meta.cum, meta.iPrev, meta.iNext, meta.posD);
          const angle = headingOnSlice(meta, meta.posD, 5);

          marker.setLatLng(ll);
          marker.setIcon(busIcon(meta.color || '#000', angle));
        }
      }
      rafId = requestAnimationFrame(animate);
    }
    rafId = requestAnimationFrame(animate);

    // ==============================
    // UI wiring & boot
    // ==============================
    searchEl.addEventListener('input', renderRoutes);
    clearBtn.addEventListener('click', () => {
      selected = new Set();
      for (const lineId of Array.from(lineLayers.keys())) removeRouteLayers(lineId);
      schedulePolling();
      for (const input of routesEl.querySelectorAll('input[type=checkbox]')) input.checked = false;
    });

    (async () => {
      try {
        const data = await fetchJSON(`${API}/routes`);
        allRoutes = data;
        setStatus(`Loaded ${allRoutes.length} routes.`);
        renderRoutes();
      } catch (e) {
        setStatus("Error loading routes: " + e.message, "error");
      }
    })();

    window.addEventListener('beforeunload', () => { if (rafId) cancelAnimationFrame(rafId); });
  </script>
</body>
</html>
