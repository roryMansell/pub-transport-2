<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bus RT Minimal</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial; }
    .app { display:flex; height:100%; }
    .sidebar { width:320px; border-right:1px solid #ddd; padding:12px; overflow:auto; }
    .map { flex:1; }
    .row { display:flex; gap:6px; margin-bottom:8px; }
    .muted { color:#666; font-size:12px; margin-bottom:8px; }
    .route-item { display:flex; align-items:center; gap:6px; padding:2px 0; }
    .route-id { font-family: ui-monospace, Menlo, Consolas, monospace; width:56px; }
    .loading { font-size:12px; color:#888; }
    .error { color:#b00020; font-size:12px; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <h3>London bus routes</h3>
      <div class="row">
        <input id="search" placeholder="Search route (e.g. 88, 214, N5)" style="flex:1; padding:6px;">
        <button id="clear">Clear</button>
      </div>
      <div class="muted">
        Tick routes to load vehicles. Map updates every 5s.
      </div>
      <div id="status" class="loading">Loading routes…</div>
      <div id="routes"></div>
    </div>
    <div id="map" class="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Backend API
    const API = "https://pub-transport-2.onrender.com";

    const routesEl = document.getElementById('routes');
    const searchEl = document.getElementById('search');
    const clearBtn = document.getElementById('clear');
    const statusEl = document.getElementById('status');
    let allRoutes = [];
    let selected = new Set();
    let pollTimer = null;

    // Keep per-route layers & state
    // lineId -> { group, poly_in, poly_out, stops, vehiclesState(Map) }
    const lineLayers = new Map();

    // Map
    const map = L.map('map').setView([51.5074, -0.1278], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap',
      maxZoom: 19
    }).addTo(map);

    // color utilities
    const hash = (s) => { let h=0; for (let i=0;i<s.length;i++) { h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); };
    function colorFor(lineId) {
      const h = hash(lineId) % 360;
      return `hsl(${h}, 75%, 45%)`;
    }
    const lerp = (a,b,t)=>a+(b-a)*t, clamp01=(x)=>Math.max(0,Math.min(1,x));

    async function fetchJSON(url) {
      const r = await fetch(url, { mode: "cors" });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}\n${await r.text()}`);
      return r.json();
    }

    function renderRoutes() {
      const q = (searchEl.value || "").trim().toLowerCase();
      const filtered = q
        ? allRoutes.filter(r => r.id.toLowerCase().includes(q) || (r.name||"").toLowerCase().includes(q))
        : allRoutes;

      routesEl.innerHTML = "";
      filtered.slice(0, 300).forEach(r => {
        const label = document.createElement('label');
        label.className = 'route-item';

        const swatch = document.createElement('span');
        swatch.style.display = 'inline-block';
        swatch.style.width = '10px';
        swatch.style.height = '10px';
        swatch.style.borderRadius = '50%';
        swatch.style.background = colorFor(r.id);

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selected.has(r.id);
        cb.addEventListener('change', () => {
          if (cb.checked) {
            selected.add(r.id);
            ensureRouteLoaded(r.id);
          } else {
            selected.delete(r.id);
            removeRouteLayers(r.id);
          }
          schedulePolling();
        });

        const idSpan = document.createElement('span');
        idSpan.className = 'route-id';
        idSpan.textContent = r.id;

        const nameSpan = document.createElement('span');
        nameSpan.textContent = r.name || r.id;

        label.appendChild(cb);
        label.appendChild(swatch);
        label.appendChild(idSpan);
        label.appendChild(nameSpan);
        routesEl.appendChild(label);
      });

      if (filtered.length > 300) {
        const note = document.createElement('div');
        note.className = 'muted';
        note.textContent = 'Showing first 300. Refine your search.';
        routesEl.appendChild(note);
      }
    }

    function setStatus(msg, css = "loading") {
      statusEl.className = css;
      statusEl.textContent = msg;
    }

    function schedulePolling() {
      if (pollTimer) clearInterval(pollTimer);

      // remove layers for lines that are no longer selected
      for (const [lineId, layers] of Array.from(lineLayers.entries())) {
        if (!selected.has(lineId)) removeRouteLayers(lineId);
      }

      if (selected.size === 0) {
        setStatus("No routes selected. Tick some on the left.", "muted");
        return;
      }
      setStatus("Live updating…", "muted");
      const load = () => updateVehicles(Array.from(selected));
      load();
      pollTimer = setInterval(load, 5000);
    }

    function removeRouteLayers(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      map.removeLayer(layers.group);
      lineLayers.delete(lineId);
    }

    async function ensureRouteLoaded(lineId) {
      if (lineLayers.has(lineId)) return; // already loaded
      const color = colorFor(lineId);

      // base group for this route
      const group = L.layerGroup().addTo(map);
      const vehiclesState = new Map(); // key -> { marker, meta }

      // fetch stops/shape
      const seq = await fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/stops`);
      const toLatLngs = (arr) => arr.filter(s => s.lat != null && s.lon != null).map(s => [s.lat, s.lon]);

      const inboundLL = toLatLngs(seq.inbound || []);
      const outboundLL = toLatLngs(seq.outbound || []);

      // polylines (different dash for outbound)
      const poly_in = inboundLL.length ? L.polyline(inboundLL, { color, weight: 4, opacity: 0.8 }).addTo(group) : null;
      const poly_out = outboundLL.length ? L.polyline(outboundLL, { color, weight: 4, opacity: 0.5, dashArray: "6,6" }).addTo(group) : null;

      // stops as small circle markers
      const stopsLayer = L.layerGroup().addTo(group);
      const addStops = (arr) => {
        arr.forEach(sp => {
          if (sp.lat == null || sp.lon == null) return;
          L.circleMarker([sp.lat, sp.lon], {
            radius: 4,
            color: color,
            weight: 1,
            fillOpacity: 0.9
          }).bindPopup(`<b>${sp.name || "Stop"}</b>`).addTo(stopsLayer);
        });
      };
      addStops(seq.inbound || []);
      addStops(seq.outbound || []);

      lineLayers.set(lineId, { group, poly_in, poly_out, stops: stopsLayer, vehiclesState, color });
    }

    async function updateVehicles(lines) {
      try {
        // ensure routes are loaded (for polylines/stops & color)
        await Promise.all(lines.map(ensureRouteLoaded));
        await Promise.all(lines.map(loadLine));
      } catch (e) {
        setStatus("Error: " + e.message, "error");
      }
    }

    // load vehicles for one line and update animation state
    async function loadLine(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      const { vehiclesState, color } = layers;

      const data = await fetchJSON(`${API}/vehicles?line_id=${encodeURIComponent(lineId)}`);
      const fetchedAt = Date.parse(data.fetched_at || new Date().toISOString());
      const vehicles = data.vehicles || [];
      const seen = new Set();

      for (const v of vehicles) {
        const key = `${lineId}::${v.vehicle_id}`;
        seen.add(key);

        const hasPrev = (v.prev_lat != null && v.prev_lon != null);
        const hasNext = (v.next_lat != null && v.next_lon != null);
        if (!hasPrev && !hasNext) continue;

        let st = vehiclesState.get(key);
        if (!st) {
          // draw buses as colored circleMarkers so each route has its own color
          const lat0 = hasPrev ? v.prev_lat : v.next_lat;
          const lon0 = hasPrev ? v.prev_lon : v.next_lon;
          const m = L.circleMarker([lat0, lon0], {
            radius: 7,
            color: "#000",
            weight: 1,
            fillColor: color,
            fillOpacity: 0.9
          }).addTo(layers.group);
          m.bindPopup(
            `<b>Route:</b> ${v.route}<br>` +
            `<b>Vehicle:</b> ${v.vehicle_id}<br>` +
            `<b>ETA:</b> ${Math.round(v.eta_seconds/60)} min<br>` +
            `${v.next_stop_name ? `<b>Next stop:</b> ${v.next_stop_name}` : ""}`
          );
          st = { marker: m, meta: {} };
          vehiclesState.set(key, st);
        } else {
          st.marker.getPopup()?.setContent(
            `<b>Route:</b> ${v.route}<br>` +
            `<b>Vehicle:</b> ${v.vehicle_id}<br>` +
            `<b>ETA:</b> ${Math.round(v.eta_seconds/60)} min<br>` +
            `${v.next_stop_name ? `<b>Next stop:</b> ${v.next_stop_name}` : ""}`
          );
        }

        // store interpolation meta (between prev -> next)
        st.meta = {
          prev: hasPrev ? [v.prev_lat, v.prev_lon] : (hasNext ? [v.next_lat, v.next_lon] : null),
          next: hasNext ? [v.next_lat, v.next_lon] : (hasPrev ? [v.prev_lat, v.prev_lon] : null),
          startEta: Math.max(v.eta_seconds, 1),
          syncedAtMs: Date.now()
        };
      }

      // remove stale vehicles for this line
      for (const key of Array.from(vehiclesState.keys())) {
        if (!seen.has(key)) {
          vehiclesState.get(key).marker.remove();
          vehiclesState.delete(key);
        }
      }
    }

    // animation loop — nudge markers from prev -> next between polls
    setInterval(() => {
      for (const { vehiclesState } of lineLayers.values()) {
        const now = Date.now();
        for (const st of vehiclesState.values()) {
          const { marker, meta } = st;
          if (!meta || !meta.prev || !meta.next) continue;
          const p = clamp01((now - meta.syncedAtMs) / 1000 / meta.startEta);
          const lat = lerp(meta.prev[0], meta.next[0], p);
          const lon = lerp(meta.prev[1], meta.next[1], p);
          marker.setLatLng([lat, lon]);
        }
      }
    }, 100); // ~10fps

    // UI wiring
    searchEl.addEventListener('input', renderRoutes);
    clearBtn.addEventListener('click', () => {
      selected = new Set();
      // remove all route layers
      for (const [lineId] of lineLayers) removeRouteLayers(lineId);
      schedulePolling();
      // uncheck all
      for (const input of routesEl.querySelectorAll('input[type=checkbox]')) input.checked = false;
    });

    // Boot
    (async () => {
      try {
        const data = await fetchJSON(`${API}/routes`);
        allRoutes = data;
        setStatus(`Loaded ${allRoutes.length} routes.`);
        renderRoutes();
      } catch (e) {
        setStatus("Error loading routes: " + e.message, "error");
      }
    })();
  </script>
</body>
</html>
