<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>London Bus RT – Minimal (solid)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial; }
    .app { display:flex; height:100%; }
    .sidebar { width:320px; border-right:1px solid #ddd; padding:12px; overflow:auto; }
    .map { flex:1; }
    .row { display:flex; gap:6px; margin-bottom:8px; }
    .muted { color:#666; font-size:12px; margin-bottom:8px; }
    .route-item { display:flex; align-items:center; gap:8px; padding:3px 0; }
    .route-id { font-family: ui-monospace, Menlo, Consolas, monospace; width:56px; }
    .loading { font-size:12px; color:#888; }
    .error { color:#b00020; font-size:12px; white-space:pre-wrap; }
    .leaflet-pane .vehicle-arrow { z-index: 500; }
    button { cursor:pointer; }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <h3>London bus routes</h3>
      <div class="row">
        <input id="search" placeholder="Search route (e.g. 88, 214, N5)" style="flex:1; padding:6px;">
        <button id="clear">Clear</button>
      </div>
      <div class="muted">Tick routes to load vehicles. Map updates every 5s; animation is continuous.</div>
      <div class="muted" style="margin-bottom:6px;">
        <span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#888;vertical-align:middle;margin-right:6px;border:2px solid #0002"></span>
        Stops are white dots with a colored ring. Buses are colored arrows that move along the route.
      </div>
      <div id="status" class="loading">Loading routes…</div>
      <div id="routes"></div>
    </div>
    <div id="map" class="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ==============================
    // Config
    // ==============================
    const API = "https://pub-transport-2.onrender.com";

    // ==============================
    // DOM/state
    // ==============================
    const routesEl = document.getElementById('routes');
    const searchEl = document.getElementById('search');
    const clearBtn = document.getElementById('clear');
    const statusEl = document.getElementById('status');

    let allRoutes = [];
    let selected = new Set();
    let pollTimer = null;

    // lineId -> {
    //   group, vehiclesState(Map), color,
    //   pathIn, cumIn, idxInByStop(Map),
    //   pathOut, cumOut, idxOutByStop(Map)
    // }
    const lineLayers = new Map();

    // ==============================
    // Map
    // ==============================
    const map = L.map('map').setView([51.5074, -0.1278], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap',
      maxZoom: 19
    }).addTo(map);

    // ==============================
    // Helpers
    // ==============================
    const hash = (s) => { let h=0; for (let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); };
    const colorFor = (lineId) => `hsl(${hash(lineId)%360}, 75%, 45%)`;

    function bearingDeg(lat1, lon1, lat2, lon2) {
      const toRad = d => d*Math.PI/180, toDeg = r => r*180/Math.PI;
      const φ1 = toRad(lat1), φ2 = toRad(lat2), Δλ = toRad(lon2 - lon1);
      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      let brng = toDeg(Math.atan2(y, x));
      return (brng + 360) % 360;
    }

    function busIcon(color, rotationDeg) {
      const html =
        `<div class="vehicle-arrow" style="transform: rotate(${rotationDeg}deg); transform-origin: 50% 50%;">
           <div style="
             width:0; height:0;
             border-left:9px solid transparent;
             border-right:9px solid transparent;
             border-bottom:18px solid ${color};
             filter: drop-shadow(0 1px 2px rgba(0,0,0,0.45));
           "></div>
         </div>`;
      return L.divIcon({ className: 'bus-divicon', html, iconSize: [20,20], iconAnchor: [10,10] });
    }

    async function fetchJSON(url) {
      const r = await fetch(url, { mode: "cors" });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}\n${await r.text()}`);
      return r.json();
    }

    function setStatus(msg, css = "loading") { statusEl.className = css; statusEl.textContent = msg; }

    function normalizeKey(lineId, vehicleId) {
      return `${String(lineId).trim()}::${String(vehicleId).trim()}`;
    }

    function renderRoutes() {
      const q = (searchEl.value || "").trim().toLowerCase();
      const filtered = q
        ? allRoutes.filter(r => r.id.toLowerCase().includes(q) || (r.name||"").toLowerCase().includes(q))
        : allRoutes;

      routesEl.innerHTML = "";
      filtered.slice(0, 300).forEach(r => {
        const label = document.createElement('label');
        label.className = 'route-item';

        const swatch = document.createElement('span');
        Object.assign(swatch.style, { display:'inline-block', width:'10px', height:'10px', borderRadius:'50%', background: colorFor(r.id) });

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selected.has(r.id);
        cb.addEventListener('change', () => {
          if (cb.checked) { selected.add(r.id); ensureRouteLoaded(r.id); }
          else { selected.delete(r.id); removeRouteLayers(r.id); }
          schedulePolling();
        });

        const idSpan = document.createElement('span'); idSpan.className = 'route-id'; idSpan.textContent = r.id;
        const nameSpan = document.createElement('span'); nameSpan.textContent = r.name || r.id;

        label.appendChild(cb); label.appendChild(swatch); label.appendChild(idSpan); label.appendChild(nameSpan);
        routesEl.appendChild(label);
      });

      if (filtered.length > 300) {
        const note = document.createElement('div'); note.className = 'muted'; note.textContent = 'Showing first 300. Refine your search.'; routesEl.appendChild(note);
      }
    }

    function schedulePolling() {
      if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }

      for (const id of Array.from(lineLayers.keys())) {
        if (!selected.has(id)) removeRouteLayers(id);
      }

      if (selected.size === 0) {
        map.eachLayer(l => { if (!(l instanceof L.TileLayer)) { try { l.remove(); } catch { map.removeLayer(l); } } });
        setStatus("No routes selected. Tick some on the left.", "muted");
        return;
      }

      setStatus("Live updating…", "muted");

      const load = async () => {
        const lines = Array.from(selected);
        try {
          await updateVehicles(lines);
        } catch (e) {
          setStatus("Error: " + e.message, "error");
        }
      };

      load();
      pollTimer = setInterval(load, 5000);
    }

    function removeRouteLayers(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      try { layers.group.remove(); } catch { map.removeLayer(layers.group); }
      lineLayers.delete(lineId);
    }

    // ==============================
    // Polyline helpers
    // ==============================
    function haversineMeters(a, b) {
      const R = 6371000;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(b[0] - a[0]);
      const dLon = toRad(b[1] - a[1]);
      const lat1 = toRad(a[0]), lat2 = toRad(b[0]);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(s));
    }
    function cumulativeDistances(points) {
      const cum = [0];
      for (let i = 1; i < points.length; i++) cum[i] = cum[i-1] + haversineMeters(points[i-1], points[i]);
      return cum;
    }
    function interpolateBetween(a, b, t) { return [a[0] + (b[0]-a[0]) * t, a[1] + (b[1]-a[1]) * t]; }
    function lowerBound(cum, lo, hi, target) {
      lo = Math.max(0, lo); hi = Math.min(cum.length-1, hi);
      while (lo < hi) { const mid = (lo+hi)>>1; if (cum[mid] < target) lo = mid+1; else hi = mid; }
      return lo;
    }
    function pointAtDistanceOnAB(points, cum, iA, iB, targetD) {
      const i0 = Math.min(iA, iB), i1 = Math.max(iA, iB);
      const startD = cum[i0], endD = cum[i1];
      const tDist = Math.max(startD, Math.min(endD, targetD));
      const j = lowerBound(cum, i0, i1, tDist);
      if (j === i0) return points[i0];
      const segLen = cum[j] - cum[j-1];
      const segT = segLen > 0 ? (tDist - cum[j-1]) / segLen : 0;
      return interpolateBetween(points[j-1], points[j], Math.max(0, Math.min(1, segT)));
    }

    // ==============================
    // Load lines (shape + stops)
    // ==============================
    async function ensureRouteLoaded(lineId) {
      if (lineLayers.has(lineId)) return;
      const color = colorFor(lineId);

      const group = L.featureGroup().addTo(map);
      const vehiclesState = new Map();

      const [shape, stops] = await Promise.all([
        fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/shape`),
        fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/stops`)
      ]);

      const pickPath = (segments) => {
        let best = null;
        for (const s of (segments || [])) if (Array.isArray(s) && s.length >= 2) best = !best || s.length > best.length ? s : best;
        return best || [];
      };
      const pathIn = pickPath(shape.inbound);
      const pathOut = pickPath(shape.outbound);

      const cumIn  = pathIn.length  ? cumulativeDistances(pathIn)  : [];
      const cumOut = pathOut.length ? cumulativeDistances(pathOut) : [];

      const nearestIndex = (path, stop) => {
        if (!path.length) return null;
        let bestIdx = 0, bestD = Infinity;
        for (let i = 0; i < path.length; i++) {
          const d = haversineMeters(path[i], [stop.lat, stop.lon]);
          if (d < bestD) { bestD = d; bestIdx = i; }
        }
        return bestIdx;
      };
      const idxInByStop = new Map();
      const idxOutByStop = new Map();
      (stops.inbound || []).forEach(sp => { if (sp.lat!=null && sp.lon!=null) { const idx = nearestIndex(pathIn, sp); if (idx!=null) idxInByStop.set(sp.id, idx); }});
      (stops.outbound || []).forEach(sp => { if (sp.lat!=null && sp.lon!=null) { const idx = nearestIndex(pathOut, sp); if (idx!=null) idxOutByStop.set(sp.id, idx); }});

      if (pathIn.length)  L.polyline(pathIn,  { color, weight: 4, opacity: 0.85 }).addTo(group);
      if (pathOut.length) L.polyline(pathOut, { color, weight: 4, opacity: 0.55, dashArray: "6,6" }).addTo(group);

      const stopsLayer = L.layerGroup().addTo(group);
      const addStops = (arr) => (arr || []).forEach(sp => {
        if (sp.lat == null || sp.lon == null) return;
        L.circleMarker([sp.lat, sp.lon], { radius: 6, color: '#0000', weight: 0, fillColor: '#000', fillOpacity: 0.08 }).addTo(stopsLayer);
        L.circleMarker([sp.lat, sp.lon], { radius: 5, color, weight: 3, fillColor: '#fff', fillOpacity: 1.0 })
          .bindPopup(`<b>${sp.name || "Stop"}</b>`, { autoPan: false })
          .addTo(stopsLayer);
      });
      addStops(stops.inbound); addStops(stops.outbound);

      const allPts = [...pathIn, ...pathOut];
      if (allPts.length) {
        const b = L.latLngBounds(allPts.map(p => L.latLng(p[0], p[1])));
        map.fitBounds(b, { padding: [20, 20], maxZoom: 14 });
      }

      lineLayers.set(lineId, { group, vehiclesState, color,
        pathIn, cumIn, idxInByStop,
        pathOut, cumOut, idxOutByStop
      });
    }

    // ==============================
    // Vehicles: poll + maintain segment windows
    // ==============================
    async function updateVehicles(lines) {
      await Promise.all(lines.map(ensureRouteLoaded));
      await Promise.all(lines.map(loadLine));
    }

    function popupHtml(v) {
      return (
        `<b>Route:</b> ${v.route}<br>` +
        `<b>Vehicle:</b> ${v.vehicle_id}<br>` +
        (v.eta_seconds != null ? `<b>ETA:</b> ${Math.max(0, Math.round(v.eta_seconds/60))} min<br>` : "") +
        `${v.next_stop_name ? `<b>Next stop:</b> ${v.next_stop_name}` : ""}`
      );
    }

    function projectNow(meta, nowMs) {
      const { startMs, endMs, startD, endD } = meta;
      const dur = Math.max(1, endMs - startMs);
      const p = Math.max(0, Math.min(1, (nowMs - startMs) / dur));
      return startD + (endD - startD) * p;
    }

    async function loadLine(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      const { vehiclesState, color, pathIn, cumIn, idxInByStop, pathOut, cumOut, idxOutByStop } = layers;

      const data = await fetchJSON(`${API}/vehicles?line_id=${encodeURIComponent(lineId)}`);
      const fetchedAtMs = Date.parse(data.fetched_at || new Date().toISOString());
      const vehicles = data.vehicles || [];
      const seenKeys = new Set();

      for (const v of vehicles) {
        const key = normalizeKey(lineId, v.vehicle_id);
        seenKeys.add(key);

        const hasPrev = (v.prev_stop_id && v.prev_lat != null && v.prev_lon != null);
        const hasNext = (v.next_stop_id && v.next_lat != null && v.next_lon != null);
        if (!hasPrev || !hasNext) continue;

        const dir = (v.direction || "").toLowerCase().startsWith("out") ? "outbound" : "inbound";
        const path = dir === "outbound" ? pathOut : pathIn;
        const cum  = dir === "outbound" ? cumOut  : cumIn;
        const idxMap  = dir === "outbound" ? idxOutByStop : idxInByStop;

        if (!path.length || !cum.length) continue;

        const iPrev = idxMap.get(v.prev_stop_id);
        const iNext = idxMap.get(v.next_stop_id);
        if (iPrev == null || iNext == null || iPrev === iNext) continue;

        const rot = bearingDeg(v.prev_lat, v.prev_lon, v.next_lat, v.next_lon);
        const cumA = cum[iPrev], cumB = cum[iNext];

        let st = vehiclesState.get(key);

        // create marker once
        if (!st) {
          const m = L.marker([v.prev_lat, v.prev_lon], { icon: busIcon(color, rot) }).addTo(layers.group);
          m.bindPopup(popupHtml(v), { autoPan: false, closeButton: true, autoClose: false });
          st = { marker: m, meta: null };
          vehiclesState.set(key, st);
        } else {
          st.marker.setIcon(busIcon(color, rot));
          st.marker.getPopup()?.setContent(popupHtml(v));
        }

        const etaSec = Math.max(1, v.eta_seconds || 1);
        const newEndMs = fetchedAtMs + etaSec * 1000;

        // Establish / update segment window
        if (!st.meta) {
          st.meta = {
            dir, iPrev, iNext, next_stop_id: v.next_stop_id,
            path, cum,
            startMs: fetchedAtMs - 300, // slight head start
            endMs: newEndMs,
            startD: cumA,
            endD: cumB
          };
          // place immediately at tiny offset from start to avoid "on-stop" look
          const tiny = Math.max(2, Math.abs(cumB - cumA) * 0.02);
          const initD = cumA < cumB ? cumA + tiny : cumA - tiny;
          const ll = pointAtDistanceOnAB(path, cum, iPrev, iNext, initD);
          st.marker.setLatLng(ll);
        } else {
          const sameSlice = st.meta.dir === dir && st.meta.iPrev === iPrev && st.meta.iNext === iNext && st.meta.next_stop_id === v.next_stop_id;
          const now = fetchedAtMs;

          if (sameSlice) {
            // Keep current progress, only relax/advance endMs
            const currD = projectNow(st.meta, now);
            st.meta.startD = currD;
            st.meta.endD = cumB;
            st.meta.startMs = now;
            // if ETA increased, endMs goes later; if it decreased, we bring it forward (no backward jump in distance)
            st.meta.endMs = newEndMs;
            st.meta.path = path; st.meta.cum = cum;
          } else {
            // New slice: begin from current projected position on old slice, not the stop
            const currD = projectNow(st.meta, now);
            st.meta = {
              dir, iPrev, iNext, next_stop_id: v.next_stop_id,
              path, cum,
              startMs: now,
              endMs: newEndMs,
              startD: currD,
              endD: cumB
            };
          }
        }
      }

      // Remove stale vehicles for this line
      for (const [key, st] of Array.from(vehiclesState.entries())) {
        if (!seenKeys.has(key)) {
          try { st.marker.remove(); } catch {}
          vehiclesState.delete(key);
        }
      }
    }

    // ==============================
    // Animation loop (requestAnimationFrame)
    // ==============================
    let rafId = null;
    function animate() {
      const now = Date.now();
      for (const { vehiclesState } of lineLayers.values()) {
        for (const st of vehiclesState.values()) {
          const { marker, meta } = st;
          if (!meta || !meta.path || !meta.cum) continue;

          const currD = projectNow(meta, now);
          const ll = pointAtDistanceOnAB(meta.path, meta.cum, meta.iPrev, meta.iNext, currD);
          marker.setLatLng(ll);
        }
      }
      rafId = requestAnimationFrame(animate);
    }
    rafId = requestAnimationFrame(animate);

    // ==============================
    // UI wiring & boot
    // ==============================
    searchEl.addEventListener('input', renderRoutes);
    clearBtn.addEventListener('click', () => {
      selected = new Set();
      for (const lineId of Array.from(lineLayers.keys())) removeRouteLayers(lineId);
      schedulePolling();
      for (const input of routesEl.querySelectorAll('input[type=checkbox]')) input.checked = false;
    });

    (async () => {
      try {
        const data = await fetchJSON(`${API}/routes`);
        allRoutes = data;
        setStatus(`Loaded ${allRoutes.length} routes.`);
        renderRoutes();
      } catch (e) {
        setStatus("Error loading routes: " + e.message, "error");
      }
    })();

    // Clean up RAF on unload
    window.addEventListener('beforeunload', () => { if (rafId) cancelAnimationFrame(rafId); });
  </script>
</body>
</html>
