<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>London Bus RT – Route ETAs (stable demo)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell; }
    .app { display:flex; height:100%; }
    .sidebar { width:360px; border-right:1px solid #ddd; padding:12px; overflow:auto; }
    .map { flex:1; }
    .row { display:flex; gap:8px; margin-bottom:10px; }
    .muted { color:#666; font-size:12px; margin:6px 0; }
    .section-title { font-size:12px; font-weight:600; text-transform:uppercase; letter-spacing:.04em; color:#555; margin:10px 0 6px; }
    .route-item { display:flex; align-items:center; gap:8px; padding:4px 0; }
    .route-id { font-family: ui-monospace, Menlo, Consolas, monospace; width:60px; }
    .loading { font-size:12px; color:#888; }
    .error { color:#b00020; font-size:12px; white-space:pre-wrap; }
    .eta-list { border:1px solid #eee; border-radius:8px; padding:8px; }
    .eta-row { display:flex; align-items:center; justify-content:space-between; padding:6px 0; border-top:1px dashed #eee; }
    .eta-row:first-child { border-top:none; }
    .eta-stop { display:flex; flex-direction:column; }
    .eta-stop .name { font-weight:600; }
    .eta-stop .dir { font-size:12px; color:#666; }
    .eta-badge { font-variant-numeric: tabular-nums; padding:2px 8px; border-radius:999px; background:#eee; }
    .legend { display:flex; gap:8px; align-items:center; font-size:12px; }
    .sw { width:10px;height:10px;border-radius:50%;display:inline-block;border:2px solid #0002; }
    .leaflet-pane .vehicle-arrow { z-index: 500; }
    .bus-divicon { pointer-events:auto; }
    .footer { display:flex; justify-content:space-between; align-items:center; font-size:12px; color:#666; margin-top:10px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="sidebar">
      <h3 style="margin:6px 0 10px;">London bus routes</h3>
      <div class="row">
        <input id="search" placeholder="Search route (e.g. 88, 214, N5)" style="flex:1; padding:8px;">
        <button id="clear">Clear</button>
      </div>
      <div class="muted">Select a route to draw its shape and stops. Live ETAs refresh every 10s.</div>
      <label class="muted" style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="showVehicles"> Show approximate bus markers (beta)
      </label>

      <div class="legend muted" style="margin-top:6px;">
        <span class="sw" style="background:#2ecc71"></span> &lt; 5m
        <span class="sw" style="background:#f39c12"></span> 5–10m
        <span class="sw" style="background:#e74c3c"></span> &gt; 10m
        <span class="sw" style="background:#bbb"></span> none
      </div>

      <div id="status" class="loading" style="margin-top:10px;">Loading routes…</div>
      <div id="routes"></div>

      <div class="section-title">Upcoming arrivals (selected route)</div>
      <div id="arrivals" class="eta-list muted">Select a route to see live arrivals.</div>

      <div class="footer">
        <span id="lastUpdated">—</span>
        <button id="refresh">Refresh</button>
      </div>
    </div>
    <div id="map" class="map"></div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ==============================
    // Config
    // ==============================
    const API = "https://pub-transport-2.onrender.com";
    const POLL_MS = 10000;
    const AVG_SPEED_MPS = 7; // for optional approximate markers only

    // ==============================
    // DOM/state
    // ==============================
    const routesEl = document.getElementById('routes');
    const searchEl = document.getElementById('search');
    const clearBtn = document.getElementById('clear');
    const statusEl = document.getElementById('status');
    const arrivalsEl = document.getElementById('arrivals');
    const lastUpdatedEl = document.getElementById('lastUpdated');
    const refreshBtn = document.getElementById('refresh');
    const showVehiclesEl = document.getElementById('showVehicles');

    let allRoutes = [];
    let selected = new Set();
    let pollTimer = null;

    // lineId -> {
    //   group, color,
    //   pathIn, cumIn, idxInByStop(Map), stopsIn(Map id->stop), dInByStop(Map id->D),
    //   pathOut, cumOut, idxOutByStop(Map), stopsOut(Map), dOutByStop(Map),
    //   vehicleLayer (group for beta markers)
    // }
    const lineLayers = new Map();

    // ==============================
    // Map
    // ==============================
    const map = L.map('map').setView([51.5074, -0.1278], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap', maxZoom: 19
    }).addTo(map);

    // ==============================
    // Helpers
    // ==============================
    const hash = (s) => { let h=0; for (let i=0;i<s.length;i++){ h=((h<<5)-h)+s.charCodeAt(i); h|=0; } return Math.abs(h); };
    const colorFor = (lineId) => `hsl(${hash(lineId)%360}, 75%, 45%)`;
    const vKey = (lineId, vid) => `${String(lineId).trim()}::${String(vid).trim()}`;
    const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
    const lerp  = (a,b,t) => a + (b-a)*t;

    function setStatus(msg, css = "loading") { statusEl.className = css; statusEl.textContent = msg; }
    async function fetchJSON(url) {
      const r = await fetch(url, { mode: "cors", cache: "no-store" });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}\n${await r.text()}`);
      return r.json();
    }

    // distances + interpolation
    function haversineMeters(a,b){ const R=6371000, toRad=x=>x*Math.PI/180;
      const dLat=toRad(b[0]-a[0]), dLon=toRad(b[1]-a[1]);
      const lat1=toRad(a[0]), lat2=toRad(b[0]);
      const s=Math.sin(dLat/2)**2+Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(s));
    }
    function cumulativeDistances(points){ const cum=[0]; for(let i=1;i<points.length;i++) cum[i]=cum[i-1]+haversineMeters(points[i-1],points[i]); return cum; }
    function lowerBound(cum, lo, hi, target) {
      lo=Math.max(0,lo); hi=Math.min(cum.length-1,hi);
      while(lo<hi){ const mid=(lo+hi)>>1; if(cum[mid]<target) lo=mid+1; else hi=mid; }
      return lo;
    }
    function pointAtDistanceOnSlice(points, cum, iA, iB, targetD){
      const i0=Math.min(iA,iB), i1=Math.max(iA,iB);
      const startD=cum[i0], endD=cum[i1];
      const tDist=clamp(targetD,startD,endD);
      const j=lowerBound(cum,i0,i1,tDist);
      if(j===i0) return points[i0];
      const segLen=cum[j]-cum[j-1];
      const segT=segLen>0? (tDist-cum[j-1])/segLen : 0;
      return [ lerp(points[j-1][0], points[j][0], clamp(segT,0,1)),
               lerp(points[j-1][1], points[j][1], clamp(segT,0,1)) ];
    }
    function headingOnSlice(meta, posD, step=5){
      const { path, cum, iPrev, iNext } = meta;
      const dirSign = Math.sign(cum[iNext]-cum[iPrev])||1;
      const a = pointAtDistanceOnSlice(path, cum, iPrev, iNext, posD - step*dirSign);
      const b = pointAtDistanceOnSlice(path, cum, iPrev, iNext, posD + step*dirSign);
      const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
      const φ1 = toRad(a[0]), φ2 = toRad(b[0]), Δλ = toRad(b[1]-a[1]);
      const y = Math.sin(Δλ)*Math.cos(φ2);
      const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
      return (toDeg(Math.atan2(y,x))+360)%360;
    }
    function projectDistanceOnSlice(points, cum, iPrev, iNext, P){
      const i0=Math.min(iPrev,iNext), i1=Math.max(iPrev,iNext);
      let bestD=cum[i0], best=Infinity, toRad=Math.PI/180;
      for(let j=i0+1;j<=i1;j++){
        const A=points[j-1], B=points[j];
        const meanLat=(A[0]+B[0])*0.5*toRad;
        const bx=(B[1]-A[1])*Math.cos(meanLat), by=(B[0]-A[0]);
        const px=(P[1]-A[1])*Math.cos(meanLat), py=(P[0]-A[0]);
        const len2=bx*bx+by*by; let t=len2>0? ((px*bx+py*by)/len2):0; t=clamp(t,0,1);
        const dx=px-bx*t, dy=py-by*t; const d2=dx*dx+dy*dy;
        if(d2<best){ best=d2; bestD = cum[j-1] + t*(cum[j]-cum[j-1]); }
      }
      return bestD;
    }
    function busIcon(color, rotationDeg) {
      const html =
        `<div class="vehicle-arrow" style="transform: rotate(${rotationDeg}deg); transform-origin: 50% 50%;">
           <div class="arrow-core" style="
             width:0; height:0;
             border-left:9px solid transparent;
             border-right:9px solid transparent;
             border-bottom:18px solid ${color};
             filter: drop-shadow(0 1px 2px rgba(0,0,0,0.45));
           "></div>
         </div>`;
      return L.divIcon({ className: 'bus-divicon', html, iconSize: [20,20], iconAnchor: [10,10] });
    }

    function etaBadge(mins){
      const m = mins;
      let bg = '#bbb';
      if (m < 5) bg = '#2ecc71';
      else if (m < 10) bg = '#f39c12';
      else if (m !== Infinity) bg = '#e74c3c';
      return `<span class="eta-badge" style="background:${bg};">${m===Infinity?'—':m+'m'}</span>`;
    }

    // ==============================
    // UI list + selection
    // ==============================
    function renderRoutes() {
      const q = (searchEl.value || "").trim().toLowerCase();
      const filtered = q ? allRoutes.filter(r =>
        r.id.toLowerCase().includes(q) || (r.name||"").toLowerCase().includes(q)
      ) : allRoutes;

      routesEl.innerHTML = "";
      filtered.slice(0, 300).forEach(r => {
        const label = document.createElement('label');
        label.className = 'route-item';

        const swatch = document.createElement('span');
        Object.assign(swatch.style, { display:'inline-block', width:'10px', height:'10px', borderRadius:'50%', background: colorFor(r.id) });

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selected.has(r.id);
        cb.addEventListener('change', () => {
          if (cb.checked) { selected.add(r.id); ensureRouteLoaded(r.id); }
          else { selected.delete(r.id); removeRouteLayers(r.id); }
          schedulePolling();
        });

        const idSpan = document.createElement('span'); idSpan.className = 'route-id'; idSpan.textContent = r.id;
        const nameSpan = document.createElement('span'); nameSpan.textContent = r.name || r.id;

        label.appendChild(cb); label.appendChild(swatch); label.appendChild(idSpan); label.appendChild(nameSpan);
        routesEl.appendChild(label);
      });

      if (filtered.length > 300) {
        const note = document.createElement('div'); note.className = 'muted';
        note.textContent = 'Showing first 300. Refine your search.';
        routesEl.appendChild(note);
      }
    }

    clearBtn.addEventListener('click', () => {
      selected = new Set();
      for (const lineId of Array.from(lineLayers.keys())) removeRouteLayers(lineId);
      schedulePolling();
      for (const input of routesEl.querySelectorAll('input[type=checkbox]')) input.checked = false;
      arrivalsEl.innerHTML = 'Select a route to see live arrivals.';
      setStatus('No routes selected. Tick some on the left.', 'muted');
    });

    refreshBtn.addEventListener('click', () => {
      if (selected.size) schedulePolling(); // triggers immediate load
    });

    searchEl.addEventListener('input', renderRoutes);
    showVehiclesEl.addEventListener('change', () => schedulePolling());

    // ==============================
    // Load lines (shapes + stops)
    // ==============================
    function removeRouteLayers(lineId) {
      const layers = lineLayers.get(lineId);
      if (!layers) return;
      try { layers.group.remove(); } catch { map.removeLayer(layers.group); }
      lineLayers.delete(lineId);
    }

    async function ensureRouteLoaded(lineId) {
      if (lineLayers.has(lineId)) return;
      const color = colorFor(lineId);

      const group = L.featureGroup().addTo(map);
      const vehicleLayer = L.layerGroup().addTo(group);

      const [shape, stops] = await Promise.all([
        fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/shape`),
        fetchJSON(`${API}/line/${encodeURIComponent(lineId)}/stops`)
      ]);

      const pickPath = (segments) => {
        let best = null;
        for (const s of (segments || [])) if (Array.isArray(s) && s.length >= 2)
          best = !best || s.length > best.length ? s : best;
        return best || [];
      };
      const pathIn = pickPath(shape.inbound);
      const pathOut = pickPath(shape.outbound);

      const cumIn  = pathIn.length  ? cumulativeDistances(pathIn)  : [];
      const cumOut = pathOut.length ? cumulativeDistances(pathOut) : [];

      // nearest index + projected distance for each stop
      const nearestIndex = (path, stop) => {
        if (!path.length) return null;
        let bestIdx = 0, bestD = Infinity;
        for (let i = 0; i < path.length; i++) {
          const d = haversineMeters(path[i], [stop.lat, stop.lon]);
          if (d < bestD) { bestD = d; bestIdx = i; }
        }
        return bestIdx;
      };
      const dStopOnPath = (path, cum, idx, stop) => {
        if (idx == null) return null;
        const i0 = Math.max(0, idx-3), i1 = Math.min(path.length-1, idx+3);
        return projectDistanceOnSlice(path, cum, i0, i1, [stop.lat, stop.lon]);
      };

      const idxInByStop = new Map(), idxOutByStop = new Map();
      const stopsIn = new Map(), stopsOut = new Map();
      const dInByStop = new Map(), dOutByStop = new Map();

      (stops.inbound || []).forEach(sp => {
        if (sp.lat==null || sp.lon==null) return;
        const idx = nearestIndex(pathIn, sp);
        if (idx!=null) {
          idxInByStop.set(sp.id, idx); stopsIn.set(sp.id, sp);
          dInByStop.set(sp.id, dStopOnPath(pathIn, cumIn, idx, sp));
        }
      });
      (stops.outbound || []).forEach(sp => {
        if (sp.lat==null || sp.lon==null) return;
        const idx = nearestIndex(pathOut, sp);
        if (idx!=null) {
          idxOutByStop.set(sp.id, idx); stopsOut.set(sp.id, sp);
          dOutByStop.set(sp.id, dStopOnPath(pathOut, cumOut, idx, sp));
        }
      });

      // polylines
      if (pathIn.length)  L.polyline(pathIn,  { color, weight: 4, opacity: 0.85 }).addTo(group);
      if (pathOut.length) L.polyline(pathOut, { color, weight: 4, opacity: 0.55, dashArray: "6,6" }).addTo(group);

      // stops (we'll recolor by ETA later)
      const stopsLayer = L.layerGroup().addTo(group);
      function addStops(arr, dirLabel) {
        (arr || []).forEach(sp => {
          if (sp.lat == null || sp.lon == null) return;
          const ring = L.circleMarker([sp.lat, sp.lon], { radius: 6, color:'#0000', weight:0, fillColor:'#000', fillOpacity:0.08 }).addTo(stopsLayer);
          const cm = L.circleMarker([sp.lat, sp.lon], { radius: 5, color, weight: 3, fillColor:'#bbb', fillOpacity:1 });
          cm.bindPopup(`<b>${sp.name || "Stop"}</b><br><small>${dirLabel}</small>`, { autoPan:false });
          cm.addTo(stopsLayer);
          sp._ring = ring; sp._cm = cm; // keep refs for recolor
        });
      }
      addStops(stops.inbound, 'Inbound'); addStops(stops.outbound, 'Outbound');

      // fit once
      const allPts = [...pathIn, ...pathOut];
      if (allPts.length) {
        const b = L.latLngBounds(allPts.map(p => L.latLng(p[0], p[1])));
        map.fitBounds(b, { padding:[20,20], maxZoom:14 });
      }

      lineLayers.set(lineId, {
        group, color,
        pathIn, cumIn, idxInByStop, stopsIn, dInByStop,
        pathOut, cumOut, idxOutByStop, stopsOut, dOutByStop,
        stopsLayer, vehicleLayer
      });
    }

    // ==============================
    // Polling (stable ETAs + optional markers)
    // ==============================
    function schedulePolling() {
      if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }

      // remove unselected lines
      for (const id of Array.from(lineLayers.keys())) {
        if (!selected.has(id)) removeRouteLayers(id);
      }

      if (selected.size === 0) {
        setStatus("No routes selected. Tick some on the left.", "muted");
        arrivalsEl.innerHTML = 'Select a route to see live arrivals.';
        lastUpdatedEl.textContent = '—';
        return;
      }

      setStatus("Live updating…", "muted");

      const load = async () => {
        const lines = Array.from(selected);
        try {
          await Promise.all(lines.map(ensureRouteLoaded));
          await Promise.all(lines.map(updateLineETAs));
          lastUpdatedEl.textContent = "Updated " + new Date().toLocaleTimeString();
        } catch (e) {
          setStatus("Error: " + e.message, "error");
        }
      };

      load();
      pollTimer = setInterval(load, POLL_MS);
    }

    function recolorStopCircle(stop, mins) {
      let fill = '#bbb';
      if (mins < 5) fill = '#2ecc71';
      else if (mins < 10) fill = '#f39c12';
      else if (mins !== Infinity) fill = '#e74c3c';
      if (stop._cm) stop._cm.setStyle({ fillColor: fill });
    }

    function busMarkerAt(path, cum, iPrev, iNext, etaSeconds) {
      // place approx between prev->next using simple speed guess (no tween)
      const startD = cum[iPrev], endD = cum[iNext];
      const length = Math.abs(endD - startD);
      const estDur = Math.max(20, length / AVG_SPEED_MPS);
      let p = 1 - (etaSeconds / estDur);
      p = clamp(p, 0.02, 0.98);
      const dirSign = Math.sign(endD - startD) || 1;
      const posD = startD + dirSign * (p * length);
      const latlng = pointAtDistanceOnSlice(path, cum, iPrev, iNext, posD);
      const angle = headingOnSlice({ path, cum, iPrev, iNext }, posD, 5);
      return { latlng, angle };
    }

    async function updateLineETAs(lineId) {
      const LAY = lineLayers.get(lineId);
      if (!LAY) return;

      const { color, pathIn, cumIn, idxInByStop, stopsIn, dInByStop,
                      pathOut, cumOut, idxOutByStop, stopsOut, dOutByStop, vehicleLayer } = LAY;

      const data = await fetchJSON(`${API}/vehicles?line_id=${encodeURIComponent(lineId)}`);
      const list = data.vehicles || [];

      // group by next_stop_id
      const nextByStop = new Map(); // stopId -> [{eta_seconds, direction, vehicle_id, route}]
      list.forEach(v => {
        if (!v.next_stop_id || v.eta_seconds == null) return;
        const arr = nextByStop.get(v.next_stop_id) || [];
        arr.push(v);
        nextByStop.set(v.next_stop_id, arr);
      });

      // Build arrivals table (top 12 soonest across the route)
      const rows = [];
      for (const [stopId, arr] of nextByStop.entries()) {
        const mins = Math.round(Math.min(...arr.map(x => x.eta_seconds)) / 60);
        const stop = stopsIn.get(stopId) || stopsOut.get(stopId);
        if (!stop) continue;
        rows.push({
          stopId,
          stopName: stop.name || stopId,
          mins,
          count: arr.length,
          dir: (arr[0]?.direction || '').toLowerCase()
        });
      }
      rows.sort((a,b)=> a.mins - b.mins);
      arrivalsEl.classList.remove('muted');
      arrivalsEl.innerHTML = rows.length
        ? rows.slice(0,12).map(r => (
            `<div class="eta-row">
               <div class="eta-stop">
                 <span class="name">${r.stopName}</span>
                 <span class="dir">${r.dir || ''} • ${r.count} incoming</span>
               </div>
               ${etaBadge(r.mins)}
             </div>`
          )).join('')
        : '<div class="muted">No live arrivals right now.</div>';

      // Recolor stop circles by their soonest ETA
      for (const [id, sp] of stopsIn.entries()) {
        const arr = nextByStop.get(id);
        const mins = arr ? Math.round(Math.min(...arr.map(x => x.eta_seconds))/60) : Infinity;
        recolorStopCircle(sp, mins);
      }
      for (const [id, sp] of stopsOut.entries()) {
        const arr = nextByStop.get(id);
        const mins = arr ? Math.round(Math.min(...arr.map(x => x.eta_seconds))/60) : Infinity;
        recolorStopCircle(sp, mins);
      }

      // Optional: approximate bus markers (beta) — refreshed each poll, no tween
      vehicleLayer.clearLayers();
      if (showVehiclesEl.checked) {
        list.forEach(v => {
          const dirOut = (v.direction || '').toLowerCase().startsWith('out');
          const path   = dirOut ? pathOut : pathIn;
          const cum    = dirOut ? cumOut  : cumIn;
          const idxMap = dirOut ? idxOutByStop : idxInByStop;

          if (!path.length || !cum.length) return;
          const iPrev = idxMap.get(v.prev_stop_id);
          const iNext = idxMap.get(v.next_stop_id);
          if (iPrev == null || iNext == null || iPrev === iNext) return;

          const { latlng, angle } = busMarkerAt(path, cum, iPrev, iNext, v.eta_seconds);
          const m = L.marker(latlng, { icon: busIcon(color, angle) }).addTo(vehicleLayer);
          m.bindPopup(
            `<b>${v.route}</b> • ${v.direction}<br>` +
            `${v.next_stop_name ? `<b>Next stop:</b> ${v.next_stop_name}<br>` : ''}` +
            `<b>ETA:</b> ${Math.round(v.eta_seconds/60)} min`,
            { autoPan:false }
          );
        });
      }
    }

    // ==============================
    // Boot
    // ==============================
    (async () => {
      try {
        const data = await fetchJSON(`${API}/routes`);
        allRoutes = data || [];
        setStatus(`Loaded ${allRoutes.length} routes.`, 'muted');
        renderRoutes();
      } catch (e) {
        setStatus("Error loading routes: " + e.message, "error");
      }
    })();

    function startPollingIfNeeded() {
      if (selected.size && !pollTimer) schedulePolling();
    }

    // When a route gets loaded, start polling and fit once
    async function ensureAndFocus(lineId){
      await ensureRouteLoaded(lineId);
      startPollingIfNeeded();
    }

    // click events are already wired via checkboxes
  </script>
</body>
</html>
